/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as r from "react";
import s from "prop-types";
import { validatePackage as j, classNames as q, kendoThemeMaps as A, Keys as u } from "@progress/kendo-react-common";
import { toolbarButtons as B } from "../util.mjs";
import { packageMetadata as P } from "../package-metadata.mjs";
const v = r.forwardRef((a, C) => {
  j(P);
  const {
    children: E,
    className: H,
    id: N,
    ariaLabel: T,
    keyboardNavigation: b,
    role: k,
    onResize: x,
    dir: W,
    style: K,
    tabIndex: I = h.tabIndex,
    size: y = h.size,
    fillMode: R = h.fillMode
  } = a, p = r.useRef(!1), n = r.useRef(null), f = r.useRef(0), l = r.useRef(0), o = r.useRef([]), d = r.useMemo(() => a.buttons || B, [a.buttons]), O = r.useMemo(() => d.map((e) => e + ":focus").join(","), [d]), z = () => {
    const e = n.current && n.current.querySelector(O);
    return Math.max(
      0,
      o.current.findIndex((c) => c === e)
    );
  }, g = r.useRef({ element: null, props: a });
  r.useImperativeHandle(
    g,
    () => ({
      element: n.current,
      props: a
    })
  ), r.useImperativeHandle(C, () => g.current), r.useEffect(() => (window.addEventListener("resize", w), n.current && (l.current = n.current.offsetWidth, f.current = n.current.offsetHeight, b !== !1 && (o.current = Array.from(
    n.current.querySelectorAll(d.join(","))
  ), M(0))), () => {
    window.removeEventListener("resize", w), o.current.length = 0;
  }), []), r.useEffect(() => {
    if (p.current) {
      if (!n.current || b === !1)
        return;
      o.current = Array.from(
        n.current.querySelectorAll(d.join(","))
      ), M(z());
    } else
      p.current = !0;
  });
  const M = (e) => {
    o.current.forEach((c, t) => {
      c.tabIndex = t === e ? I : -1;
    });
  }, S = (e) => {
    const c = e.keyCode === u.left || e.keyCode === u.right || e.keyCode === u.home || e.keyCode === u.end, t = z();
    !c || e.defaultPrevented || o.current.findIndex((i) => i === e.target) === -1 || (e.keyCode === u.left ? m(
      t,
      t === 0 ? o.current.length - 1 : t - 1
    ) : m(
      t,
      t === o.current.length - 1 ? 0 : t + 1
    ), e.keyCode === u.home && m(t, 0), e.keyCode === u.end && m(t, o.current.length - 1));
  }, m = (e, c) => {
    const t = o.current[c];
    if (t) {
      t.tabIndex = I, t.focus();
      const i = o.current[e];
      i && (i.tabIndex = -1);
    }
  }, w = (e) => {
    if (!n.current)
      return;
    const c = n.current.offsetWidth, t = n.current.offsetHeight;
    if (l.current !== c || f.current !== t) {
      l.current = c, f.current = t;
      const i = { offsetWidth: l.current, offsetHeight: f.current };
      x && x.call(void 0, { target: g.current, ...i, nativeEvent: e });
    }
  };
  return /* @__PURE__ */ r.createElement(
    "div",
    {
      id: N,
      "aria-label": T,
      className: q(
        "k-toolbar",
        {
          [`k-toolbar-${A.sizeMap[y] || y}`]: y,
          [`k-toolbar-${R}`]: R
        },
        H
      ),
      style: K,
      role: k !== void 0 ? k || void 0 : "toolbar",
      dir: W,
      ref: n,
      onKeyDown: b !== !1 ? S : void 0
    },
    E
  );
}), h = {
  tabIndex: 0,
  size: "medium",
  fillMode: "solid"
};
v.displayName = "KendoReactToolbar";
v.propTypes = {
  tabIndex: s.number,
  dir: s.string,
  keyboardNavigation: s.bool,
  style: s.object,
  className: s.string,
  role: s.string,
  onResize: s.func,
  buttons: s.arrayOf(s.string.isRequired),
  size: s.oneOf([null, "small", "medium", "large"]),
  fillMode: s.oneOf([null, "solid", "flat", "outline"])
};
export {
  v as Toolbar
};
